#Лабораторна робота No7. Функції

Автор: Поляч Альона Павлiвна

Група: КН-922б

Завдання:

1. Переробити програми, що були розроблені під час виконання
лабораторних робіт з тем "Масиви" та "Цикли" таким чином, щоб
використовувалися функції для обчислення результату.

2. Функції повинні задовольняти основну їх причетність - уникати
дублювання коду.
Тому, для демонстрації роботи, ваша програма (функція main()) повинна
мати можливість викликати розроблену функцію з різними вхідними
даними.

3. Слід звернути увагу: параметри одного з викликів функції повинні бути
згенеровані за допомогою генератора псевдовипадкових чисел random().

4. Слід звернути увагу (#2): продемонструвати встановлення вхідних даних
через аргументи додатка (параметри командної строки).
Обробити випадок, коли дані не передались - у цьому випадку вони
матимуть значення за умовчуванням, обраними розробником.

##Опис програми

***Функціональне призначення***

Програма виконує дві операції.

* Розраховує кіл-ть щасливих квитків.

    1. При запуску програми вводиться номер квитка, від якого
почнеться розрахунок.

    2. Якщо не буде введено номер квитка, то розрахунок буде здійснено з
білета під номером 1000 (можна вводити лише 4-цифрові числа. Якщо ввести більше, або менше цифр, то программа не працюватиме).

* Знаходить найбільше просте число в діапазоні випадкових чисел.

    1. Програма генерує випадкові числа та знаходить найбільше просте число.

</p>***Опис логічної структури***


<center>![](assets/Структура програми)
<center>*<figcaption>Графічна структура програми</figcaption>*

</p>***Вміст файлу "main.c"***

Головний файл

Це файл, який містить точку входу функйію main, виклики функцій lab05, lab06 та
значення для аргументів цих функцій.

c
main(int argc, char *argv[])


Головна функція.

Аргументи

int argc, argv *c[] Аргументі які зберігають значення введені через командний рядок

argc - зберігаеє кіл-ть значень

argv - зберігае значення<br>

Послідовність дій

* Присвоїти значення аргументам argc і argv.

    1. argc - int аргумент, що необхідний для обчислення всіх
щасливих квитків.

    2. argv - char масив, що необхідний для збереження в собі
стартового значення для перевірки всіх квитків.

* Створити змінні, яким буде надано значення для аргументів
функцій link lab05, lab06.

    1. t - зберігає стартове значення без змін, від якого
почнеться перевірка квитків для функції lab06. Його программа використовує, 
якщо користувач не ввів інших данних.

    2. x - зберігає випадкове значення, яке є мінімальним в
діапазоні для функції lab05.

    3. y - зберігає випадкове значення, яке є максимальним числом в
діапазоні для функції lab05.

    4. c - змінна яка використовується для перевірки аргументів
командного рядка.

* Згененерувати випадкові числа за допомогою генератора rand() та
функції srand(), після чого привласнити їх змінним x і y.

* Викликати функцію lab05 і присвоїти її аргументам
значення примінних x та y.

c
        srand((unsigned int)time(NULL));
        x=rand()%11;
        y=rand()%(x-1);
        lab05(x, y);


* Перевірити, чи були введені аргументи через командний
рядок.

* Якщо перевірка була пройдена, то переобразувати аргумент
командного рядка в значення типу int і присвоїти його змінній t

* Перевіртити, чи не менше t мінімального значення квитка
1000.

* Якщо перевірка була пройдена, то присвоїти t аргументам функції
lab06

* Якщо одна з перевірок не була пройдена, то присвоїти аргументам
функції lab06 значення за замовчуванням.


        if(t>1000 && t<9999)

        {

            lab06(t);

        }else

        {

            t=1000;
GitHub


        }


<center>![](assets/function - main)
<center>*<figcaption>Схема алгоритму функції main</figcaption>*

</p>***Вміст файлу "lib.c"***

Бібліотечний файл

Цей файл містить реалізацію функцій lab05, lab06.

</p>int lab05(a, b)

Ця функція знаходить найбільше просте число в рандомному діапазоні.<br>

Аргументи

a, b - діапазон чисел у якому відбувається пошук найбільшого числа

а - найбільше число діапазону

b - найменше число діапазону<br>

Послідовність дій

* Створення змінних i, max.
    1. i - використовується для перевірки просте число чи ні.

    2. max - зберігає найбільше просте число.

* Запуск циклу для перевірки чисел у встановленому діапазоні.

        while(a>b)

* Запуск циклу для того, щоб дізнатися число просте чи ні.

        while(b%i != 0){

        i++;

        }

* Перевірити, щоб дізнатися число виявилося простим чи ні.
Якщо воно просте, то перевірити чи більше воно числа яке зараз
зберігається в змінній max, якщо перевірка була пройдена то
присвоїти змінної max це число.

        if(b==i && b>max){

        max=b;

        }

<center>![](assets/lab05)
<center>*<figcaption>Схема алгоритму функції lab05</figcaption>*

</p>int lab06(k)

Ця функція знаходить усі щасливі квитки в діапазоні від k до 9999.<br>

Аргументи

k - число від якого починається пошук квитків<br>

Послідовність дій

* Створення змінних A[9999],sum1,sum2,n1,n2,n3,n4,n,i.
    1. A - масив в який записуватимемо щасливі квитки.

    2. Задати змінні sum1 і sum2 в яких буде
зберігатися суми першої і другої пари чисел.

    3. Змінні n1, n2, n3, n4 зберігатимуть по одному
числу з номера квитка.

    4. Змінна n – це кількість щасливих квитків.

* Створення циклу який перевіряє всі квитки від k до 9999.

        while( k<=9999)

* Розбити номер квитка на 4 числа.

        n1=k/1000;

        n2=(k/100)%10;

        n3=(k/10)%10;

        n4=k%10;

* Дізнатись суму першої і другої пари чисел .

        sum1=n1+n2;

        sum2=n3+n4;

* Якщо сума першої пари дорівнює сумі другої, то записати
цей квиток у масив і додати 1 до n (до кількості щасливих
квитків).

        if(sum1==sum2){

        A[n]=k;

        n++;

        }

* І збільшити номер квитка на +1.

        k++;

<center>![](assets/lab06)
<center>*<figcaption>Схема алгоритму функції lab06</figcaption>*

</p>***Вміст файлу "lib.c"***

Бібліотечний файл

Цей файл містить декларацію функцій lab05, lab06.

int lab05(int a, int b);

int lab06(long int k);<br>

Структура проекту лабораторної роботи:

├── lab07

├── Makefile

├── README.md

└── src

├── lib.c

├── lib.h

└── main.c

##Варіанти використання

* Ви можете використовувати цю програму двома методами:
        Перший спосіб - це при запуску двійкового файлу, це вказати номер квитка, з
якого буде починатися розрахунок. Як згадувалося раніше, потрібно ввести лише 4-цифрове число. Якщо введено інше число, то програма почне перевірку білетів з числа 1000. Також слід зауважити що программа може почати пошук щасливих квитків тільки від одного мінімального значення, тому якщо Вам треба дізнатися кількість квитків більше, ніж в одному діапазоні, то необхідно буде запустити программу ще раз.

* Другий метод використання цієї програми - це при запуску
двійкового файлу не вводити значення командного рядка. Тоді програма видасть список щасливих
квитків від 1000 до 9999. 

<center>![](assets/img 5)
<center>*<figcaption>Як правильно користуватися програмою!</figcaption>*<br>

* Щоб побачити результати роботи програми, вам потрібно
завантажити її в LLDB. На початку вкажіть номер квитка. Якщо Вам потрібно дізнатися найбільше просте число, то для цього Вам знадобиться встановити точку зупинки на рядку 21 у файлі lib.c та вивести значення змінної max. Якщо Вам потрібно дізнатися кількість щасливих квитків або переглянути їх, то для цього Вам потрібно зробити точку зупинки на рядку 48 у файлі lib.c. Щоб дізнатися кількість квитків, Вам потрібно вивести змінну n. А щоб переглянути щасливі квитки, вам потрібно вивести масив А[].

<center>![](assets/img 6)
<center>*<figcaption> Як дізнатися найбільше просте число!</figcaption>*<br>

<center>![](assets/img 7)
<center>![](assets/img 8)
<center>*<figcaption>Як дізнатися кількість щасливих квитків та їх перегляд!</figcaption>*<br>

##Висновок:
Навчилася користуватися функціями та правильно документувати код.
Під час тестування програми були отримані результати функції lab05 - 
це отримання найбільшого числа в діапазоні, і робота функції labb06 -
це отримання кількості щасливих квитків та їх перегляду, після введення аргументу командного рядка.
